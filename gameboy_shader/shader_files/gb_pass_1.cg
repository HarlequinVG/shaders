///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Gameboy Classic Shader                                                //
//                                                                       //
// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
//                                                                       //
// This program is free software: you can redistribute it and/or modify  //
// it under the terms of the GNU General Public License as published by  //
// the Free Software Foundation, either version 3 of the License, or     //
// (at your option) any later version.                                   //
//                                                                       //
// This program is distributed in the hope that it will be useful,       //
// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
// GNU General Public License for more details.                          //
//                                                                       //
// You should have received a copy of the GNU General Public License     //
// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//config                                                                                                                                  //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define adjacent_texel_color_blending 0.1255	//used in the quick blur filter that softens the dot-grid-dot transitions in the matrix
#define adjacent_texel_alpha_blending 0.1255	//values describe the amount of color/alpha swapped between neighboring texels
#define diagonal_texel_color_blending 0.1255	//ex. texelA float4(1.0,1.0,1.0,0.0) neighbors texelB float4(0.0,0.0,0.0,1.0), 0.2 color blending and...
#define diagonal_texel_alpha_blending 0.0627	//...0.3 alpha blending would result in texelA float4(0.8,0.8,0.8,0.3) and texelB float4(0.2,0.2,0.2,0.7)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//structs                                                                                                                                 //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct input
{
    float2 video_size;
    float2 texture_size;
    float2 output_size;
    float frame_count;
    sampler2D texture : TEXUNIT0;
};

struct blur_coords
{
    float2 tex_coord_1 : TEXCOORD1;
    float2 tex_coord_2 : TEXCOORD2;
    float2 tex_coord_3 : TEXCOORD3;
    float2 tex_coord_4 : TEXCOORD4;
    float2 lower_bound : TEXCOORD5;
    float2 upper_bound : TEXCOORD6;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//vertex shader                                                                                                                           //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void main_vertex( float4 position      			: POSITION,
  		  out float4 oPosition 			: POSITION,
  		  float2 texCoord      			: TEXCOORD0,
  		  out float2 oTexCoord 			: TEXCOORD0,
		  out blur_coords oBlurCoords,
  		  uniform float4x4 modelViewProj,
  		  uniform input IN )
{
    oPosition = mul(modelViewProj, position);
    oTexCoord = texCoord;

    float texel = 1.0 / IN.texture_size;
    oBlurCoords = blur_coords 
    (
	texCoord + float2(0.0, texel),
	texCoord + float2(0.0, -texel),
	texCoord + float2(texel, 0.0),
	texCoord + float2(-texel, 0.0),
	float2(0.0),
	texel * (IN.output_size - 2.0)
    );

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//fragment shader                                                                                                                         //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float4 main_fragment( float2 texCoord        		: TEXCOORD0, 
		      in blur_coords blur_coords,
		      uniform input IN )     		: COLOR
{
  //sample input texture

    float4 out_color = tex2D(IN.texture, texCoord);


  //obtain all the neighboring texels and clamp to prevent out of bounds sampling
  
    blur_coords.tex_coord_1 = clamp(blur_coords.tex_coord_1, blur_coords.lower_bound, blur_coords.upper_bound);
    blur_coords.tex_coord_2 = clamp(blur_coords.tex_coord_2, blur_coords.lower_bound, blur_coords.upper_bound);
    blur_coords.tex_coord_3 = clamp(blur_coords.tex_coord_3, blur_coords.lower_bound, blur_coords.upper_bound);
    blur_coords.tex_coord_4 = clamp(blur_coords.tex_coord_4, blur_coords.lower_bound, blur_coords.upper_bound);

    float2 tex_coord_d1 = clamp( float2(blur_coords.tex_coord_3.x, blur_coords.tex_coord_1.y), blur_coords.lower_bound, blur_coords.upper_bound );
    float2 tex_coord_d2 = clamp( float2(blur_coords.tex_coord_4.x, blur_coords.tex_coord_1.y), blur_coords.lower_bound, blur_coords.upper_bound );
    float2 tex_coord_d3 = clamp( float2(blur_coords.tex_coord_3.x, blur_coords.tex_coord_2.y), blur_coords.lower_bound, blur_coords.upper_bound );
    float2 tex_coord_d4 = clamp( float2(blur_coords.tex_coord_4.x, blur_coords.tex_coord_2.y), blur_coords.lower_bound, blur_coords.upper_bound );

    float4 adjacent_texel_1 = tex2D(IN.texture, blur_coords.tex_coord_1);
    float4 adjacent_texel_2 = tex2D(IN.texture, blur_coords.tex_coord_2);
    float4 adjacent_texel_3 = tex2D(IN.texture, blur_coords.tex_coord_3);
    float4 adjacent_texel_4 = tex2D(IN.texture, blur_coords.tex_coord_4);

    float4 diagonal_texel_1 = tex2D(IN.texture, tex_coord_d1);
    float4 diagonal_texel_2 = tex2D(IN.texture, tex_coord_d2);
    float4 diagonal_texel_3 = tex2D(IN.texture, tex_coord_d3);
    float4 diagonal_texel_4 = tex2D(IN.texture, tex_coord_d4);


  //simple blur for softening sharp changes in color and alpha values

    if ((adjacent_texel_1.a + adjacent_texel_2.a + adjacent_texel_3.a + adjacent_texel_4.a) >= 2.0) 		//only called on texels between two dots
    {
	out_color.rgb -= ( ((out_color.rgb - adjacent_texel_1.rgb) * adjacent_texel_1.a) + 
			   ((out_color.rgb - adjacent_texel_2.rgb) * adjacent_texel_2.a) + 
			   ((out_color.rgb - adjacent_texel_3.rgb) * adjacent_texel_3.a) + 
			   ((out_color.rgb - adjacent_texel_4.rgb) * adjacent_texel_4.a) ) * adjacent_texel_color_blending;

	out_color.a -= ( (out_color.a - adjacent_texel_1.a) + 
			 (out_color.a - adjacent_texel_2.a) + 
			 (out_color.a - adjacent_texel_3.a) + 
			 (out_color.a - adjacent_texel_4.a) ) * adjacent_texel_alpha_blending;
    }

    else if ((diagonal_texel_1.a + diagonal_texel_2.a + diagonal_texel_3.a + diagonal_texel_4.a) >= 4.0) 	//only called on texels at the center of a block of 4 dots
    {
	out_color.rgb -= ( ((out_color.rgb - diagonal_texel_1.rgb) * diagonal_texel_1.a) + 
			   ((out_color.rgb - diagonal_texel_2.rgb) * diagonal_texel_2.a) + 
			   ((out_color.rgb - diagonal_texel_3.rgb) * diagonal_texel_3.a) + 
			   ((out_color.rgb - diagonal_texel_4.rgb) * diagonal_texel_4.a) ) * diagonal_texel_color_blending;

	out_color.a -= ( (out_color.a - diagonal_texel_1.a) + 
			 (out_color.a - diagonal_texel_2.a) + 
			 (out_color.a - diagonal_texel_3.a) + 
			 (out_color.a - diagonal_texel_4.a) ) * diagonal_texel_alpha_blending;
    }

  //return
    return out_color;
}